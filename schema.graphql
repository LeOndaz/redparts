# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: Query
    mutation: Mutation
}

interface Job {
    "Created date time of job in ISO 8601 format."
    createdAt: DateTime!
    "Job message."
    message: String
    "Job status."
    status: JobStatusEnum!
    "Date time of job last update in ISO 8601 format."
    updatedAt: DateTime!
}

"An object with an ID"
interface Node {
    "The ID of the object."
    id: ID!
}

interface ObjectWithMetadata {
    "List of public metadata items. Can be accessed without permissions."
    metadata: [MetadataItem]!
    "List of private metadata items.Requires proper staff permissions to access."
    privateMetadata: [MetadataItem]!
}

"Represents user address data."
type Address implements Node {
    city: String!
    cityArea: String!
    companyName: String!
    "Shop's default country."
    country: CountryDisplay!
    countryArea: String!
    firstName: String!
    "The ID of the object."
    id: ID!
    "Address is user's default billing address."
    isDefaultBillingAddress: Boolean
    "Address is user's default shipping address."
    isDefaultShippingAddress: Boolean
    lastName: String!
    phone: String
    postalCode: String!
    streetAddress1: String!
    streetAddress2: String!
}

"Represents allocation."
type Allocation implements Node {
    "The ID of the object."
    id: ID!
    "Quantity allocated for orders."
    quantity: Int!
    "The warehouse were items were allocated."
    warehouse: Warehouse!
}

"Custom attribute of a product. Attributes can be assigned to products and variants at the product type level."
type Attribute implements Node & ObjectWithMetadata {
    "Whether the attribute can be displayed in the admin product list."
    availableInGrid: Boolean!
    "Whether the attribute can be filtered in dashboard."
    filterableInDashboard: Boolean!
    "Whether the attribute can be filtered in storefront."
    filterableInStorefront: Boolean!
    "The ID of the object."
    id: ID!
    "The input type to use for entering attribute values in the dashboard."
    inputType: AttributeInputTypeEnum
    "List of public metadata items. Can be accessed without permissions."
    metadata: [MetadataItem]!
    "Name of an attribute displayed in the interface."
    name: String
    "List of private metadata items.Requires proper staff permissions to access."
    privateMetadata: [MetadataItem]!
    productTypes(after: String, before: String, first: Int, last: Int): ProductTypeCountableConnection!
    productVariantTypes(after: String, before: String, first: Int, last: Int): ProductTypeCountableConnection!
    "Internal representation of an attribute name."
    slug: String
    "The position of the attribute in the storefront navigation (0 by default)."
    storefrontSearchPosition: Int!
    "Returns translated attribute fields for the given language code."
    translation(
        "A language code to return the translation for attribute."
        languageCode: LanguageCodeEnum!
    ): AttributeTranslation
    "The attribute type."
    type: AttributeTypeEnum
    "Whether the attribute requires values to be passed or not."
    valueRequired: Boolean!
    "List of attribute's values."
    values: [AttributeValue]
    "Whether the attribute should be visible or not in storefront."
    visibleInStorefront: Boolean!
}

type AttributeCountableConnection {
    edges: [AttributeCountableEdge!]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    "A total count of items in the collection."
    totalCount: Int
}

type AttributeCountableEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Attribute!
}

type AttributeTranslation implements Node {
    "The ID of the object."
    id: ID!
    "Translation language."
    language: LanguageDisplay!
    name: String!
}

"Represents a value of an attribute."
type AttributeValue implements Node {
    "Represents file URL and content type (if attribute value is a file)."
    file: File
    "The ID of the object."
    id: ID!
    "The input type to use for entering attribute values in the dashboard."
    inputType: AttributeInputTypeEnum
    "Name of a value displayed in the interface."
    name: String
    "Internal representation of a value (unique per attribute)."
    slug: String
    "Returns translated attribute value fields for the given language code."
    translation(
        "A language code to return the translation for attribute value."
        languageCode: LanguageCodeEnum!
    ): AttributeValueTranslation
    "Type of value (used only when `value` field is set)."
    type: AttributeValueType @deprecated(reason : "Use the `inputType` field to determine the type of attribute's value. This field will be removed after 2020-07-31.")
}

type AttributeValueTranslation implements Node {
    "The ID of the object."
    id: ID!
    "Translation language."
    language: LanguageDisplay!
    name: String!
}

"Represents a single category of products. Categories allow to organize products in a tree-hierarchies which can be used for navigation in the storefront."
type Category implements Node & ObjectWithMetadata {
    "List of ancestors of the category."
    ancestors(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int
    ): CategoryCountableConnection
    backgroundImage(
        "Size of the image."
        size: Int
    ): Image
    "List of children of the category."
    children(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int
    ): CategoryCountableConnection
    description: String!
    descriptionJson: JSONString!
    "The ID of the object."
    id: ID!
    level: Int!
    "List of public metadata items. Can be accessed without permissions."
    metadata: [MetadataItem]!
    name: String!
    parent: Category
    "List of private metadata items.Requires proper staff permissions to access."
    privateMetadata: [MetadataItem]!
    "List of products in the category."
    products(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Slug of a channel for which the data should be returned."
        channel: String,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int
    ): ProductCountableConnection
    seoDescription: String
    seoTitle: String
    slug: String!
    "Returns translated category fields for the given language code."
    translation(
        "A language code to return the translation for category."
        languageCode: LanguageCodeEnum!
    ): CategoryTranslation
    "The storefront's URL for the category."
    url: String @deprecated(reason : "This field will be removed after 2020-07-31.")
}

type CategoryCountableConnection {
    edges: [CategoryCountableEdge!]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    "A total count of items in the collection."
    totalCount: Int
}

type CategoryCountableEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Category!
}

type CategoryTranslation implements Node {
    description: String!
    descriptionJson: JSONString!
    "The ID of the object."
    id: ID!
    "Translation language."
    language: LanguageDisplay!
    name: String!
    seoDescription: String
    seoTitle: String
}

"Represents channel."
type Channel implements Node {
    currencyCode: String!
    "Whether a channel has associated orders."
    hasOrders: Boolean!
    "The ID of the object."
    id: ID!
    isActive: Boolean!
    name: String!
    slug: String!
}

"Checkout object."
type Checkout implements Node & ObjectWithMetadata {
    "List of available payment gateways."
    availablePaymentGateways: [PaymentGateway!]!
    "Shipping methods that can be used with this order."
    availableShippingMethods: [ShippingMethod]!
    billingAddress: Address
    channel: Channel!
    created: DateTime!
    discount: Money
    discountName: String
    "Email of a customer."
    email: String!
    "List of gift cards associated with this checkout."
    giftCards: [GiftCard]
    "The ID of the object."
    id: ID!
    "Returns True, if checkout requires shipping."
    isShippingRequired: Boolean!
    lastChange: DateTime!
    "A list of checkout lines, each containing information about an item in the checkout."
    lines: [CheckoutLine]
    "List of public metadata items. Can be accessed without permissions."
    metadata: [MetadataItem]!
    note: String!
    "List of private metadata items.Requires proper staff permissions to access."
    privateMetadata: [MetadataItem]!
    quantity: Int!
    shippingAddress: Address
    "The shipping method related with checkout."
    shippingMethod: ShippingMethod
    "The price of the shipping, with all the taxes included."
    shippingPrice: TaxedMoney
    "The price of the checkout before shipping, with taxes included."
    subtotalPrice: TaxedMoney
    "The checkout's token."
    token: UUID!
    "The sum of the the checkout line prices, with all the taxes,shipping costs, and discounts included."
    totalPrice: TaxedMoney
    translatedDiscountName: String
    user: User
    voucherCode: String
}

"Represents an item in the checkout."
type CheckoutLine implements Node {
    "The ID of the object."
    id: ID!
    quantity: Int!
    "Indicates whether the item need to be delivered."
    requiresShipping: Boolean
    "The sum of the checkout line price, taxes and discounts."
    totalPrice: TaxedMoney
    variant: ProductVariant!
}

"Represents a collection of products."
type Collection implements Node & ObjectWithMetadata {
    backgroundImage(
        "Size of the image."
        size: Int
    ): Image
    "List of channels in which the collection is available."
    channelListings: [CollectionChannelListing!]
    description: String!
    descriptionJson: JSONString!
    "The ID of the object."
    id: ID!
    "List of public metadata items. Can be accessed without permissions."
    metadata: [MetadataItem]!
    name: String!
    "List of private metadata items.Requires proper staff permissions to access."
    privateMetadata: [MetadataItem]!
    "List of products in this collection."
    products(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Filtering options for products."
        filter: ProductFilterInput,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int,
        "Sort products."
        sortBy: ProductOrder
    ): ProductCountableConnection
    seoDescription: String
    seoTitle: String
    slug: String!
    "Returns translated collection fields for the given language code."
    translation(
        "A language code to return the translation for collection."
        languageCode: LanguageCodeEnum!
    ): CollectionTranslation
}

"Represents collection channel listing."
type CollectionChannelListing implements Node {
    channel: Channel!
    "The ID of the object."
    id: ID!
    isPublished: Boolean!
    publicationDate: Date
}

type CollectionCountableConnection {
    edges: [CollectionCountableEdge!]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    "A total count of items in the collection."
    totalCount: Int
}

type CollectionCountableEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Collection!
}

type CollectionTranslation implements Node {
    description: String!
    descriptionJson: JSONString!
    "The ID of the object."
    id: ID!
    "Translation language."
    language: LanguageDisplay!
    name: String!
    seoDescription: String
    seoTitle: String
}

type CountryDisplay {
    "Country code."
    code: String!
    "Country name."
    country: String!
    "Country tax."
    vat: VAT
}

type CreditCard {
    "Card brand."
    brand: String!
    "Two-digit number representing the card’s expiration month."
    expMonth: Int
    "Four-digit number representing the card’s expiration year."
    expYear: Int
    "First 4 digits of the card number."
    firstDigits: String
    "Last 4 digits of the card number."
    lastDigits: String!
}

"History log of the customer."
type CustomerEvent implements Node {
    "Number of objects concerned by the event."
    count: Int
    "Date when event happened at in ISO 8601 format."
    date: DateTime
    "The ID of the object."
    id: ID!
    "Content of the event."
    message: String
    "The concerned order."
    order: Order
    "The concerned order line."
    orderLine: OrderLine
    "Customer event type."
    type: CustomerEventsEnum
    "User who performed the action."
    user: User
}

type DigitalContent implements Node & ObjectWithMetadata {
    automaticFulfillment: Boolean!
    contentFile: String!
    "The ID of the object."
    id: ID!
    maxDownloads: Int
    "List of public metadata items. Can be accessed without permissions."
    metadata: [MetadataItem]!
    "List of private metadata items.Requires proper staff permissions to access."
    privateMetadata: [MetadataItem]!
    productVariant: ProductVariant!
    urlValidDays: Int
    "List of URLs for the digital variant."
    urls: [DigitalContentUrl]
    useDefaultSettings: Boolean!
}

type DigitalContentUrl implements Node {
    content: DigitalContent!
    created: DateTime!
    downloadNum: Int!
    "The ID of the object."
    id: ID!
    "UUID of digital content."
    token: UUID!
    "URL for digital content."
    url: String
}

"Represents an error in the input of a mutation."
type Error {
    "Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field."
    field: String
    "The error message."
    message: String
}

type File {
    "Content type of the file."
    contentType: String
    "The URL of the file."
    url: String!
}

"Represents order fulfillment."
type Fulfillment implements Node & ObjectWithMetadata {
    created: DateTime!
    fulfillmentOrder: Int!
    "The ID of the object."
    id: ID!
    "List of lines for the fulfillment."
    lines: [FulfillmentLine]
    "List of public metadata items. Can be accessed without permissions."
    metadata: [MetadataItem]!
    "List of private metadata items.Requires proper staff permissions to access."
    privateMetadata: [MetadataItem]!
    status: FulfillmentStatus!
    "User-friendly fulfillment status."
    statusDisplay: String
    trackingNumber: String!
    "Warehouse from fulfillment was fulfilled."
    warehouse: Warehouse
}

"Represents line of the fulfillment."
type FulfillmentLine implements Node {
    "The ID of the object."
    id: ID!
    orderLine: OrderLine
    quantity: Int!
}

"Payment gateway client configuration key and value pair."
type GatewayConfigLine {
    "Gateway config key."
    field: String!
    "Gateway config value for key."
    value: String
}

"A gift card is a prepaid electronic payment card accepted in stores. They can be used during checkout by providing a valid gift card codes."
type GiftCard implements Node {
    "Gift card code."
    code: String
    created: DateTime!
    currentBalance: Money
    "Code in format which allows displaying in a user interface."
    displayCode: String
    endDate: Date
    "The ID of the object."
    id: ID!
    initialBalance: Money
    isActive: Boolean!
    lastUsedOn: DateTime
    startDate: Date!
    "The customer who bought a gift card."
    user: User
}

type GiftCardCountableConnection {
    edges: [GiftCardCountableEdge!]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    "A total count of items in the collection."
    totalCount: Int
}

type GiftCardCountableEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: GiftCard!
}

"Represents permission group data."
type Group implements Node {
    "The ID of the object."
    id: ID!
    name: String!
    "List of group permissions"
    permissions: [Permission]
    "True, if the currently authenticated user has rights to manage a group."
    userCanManage: Boolean!
    "List of group users"
    users: [User]
}

"Represents an image."
type Image {
    "Alt text for an image."
    alt: String
    "The URL of the image."
    url: String!
}

"Represents an Invoice."
type Invoice implements Job & Node & ObjectWithMetadata {
    "Created date time of job in ISO 8601 format."
    createdAt: DateTime!
    externalUrl: String
    "The ID of the object."
    id: ID!
    "Job message."
    message: String
    "List of public metadata items. Can be accessed without permissions."
    metadata: [MetadataItem]!
    number: String
    "List of private metadata items.Requires proper staff permissions to access."
    privateMetadata: [MetadataItem]!
    "Job status."
    status: JobStatusEnum!
    "Date time of job last update in ISO 8601 format."
    updatedAt: DateTime!
    "URL to download an invoice."
    url: String
}

type LanguageDisplay {
    "ISO 639 representation of the language name."
    code: LanguageCodeEnum!
    "Full name of the language."
    language: String!
}

type Margin {
    start: Int
    stop: Int
}

type MetadataItem {
    "Key of a metadata item."
    key: String!
    "Value of a metadata item."
    value: String!
}

"Represents amount of money in specific currency."
type Money {
    "Amount of money."
    amount: Float!
    "Currency code."
    currency: String!
    "Money formatted according to the current locale."
    localized: String! @deprecated(reason : "Price formatting according to the current locale should be handled by the frontend client. This field will be removed after 2020-07-31.")
}

"Represents a range of amounts of money."
type MoneyRange {
    "Lower bound of a price range."
    start: Money
    "Upper bound of a price range."
    stop: Money
}

type Mutation {
    "Create a review"
    reviewCreate(input: ReviewCreateInput!): ReviewCreateMutation
    "Update a review by ID"
    reviewUpdate(input: ReviewUpdateInput!): ReviewUpdateMutation
}

"Represents an order in the shop."
type Order implements Node & ObjectWithMetadata {
    "List of actions that can be performed in the current state of an order."
    actions: [OrderAction]!
    "Shipping methods that can be used with this order."
    availableShippingMethods: [ShippingMethod]
    billingAddress: Address
    "Informs whether a draft order can be finalized(turned into a regular order)."
    canFinalize: Boolean!
    channel: Channel!
    created: DateTime!
    customerNote: String!
    discount: Money
    discountName: String
    displayGrossPrices: Boolean!
    "List of events associated with the order."
    events: [OrderEvent]
    "List of shipments for the order."
    fulfillments: [Fulfillment]!
    "List of user gift cards."
    giftCards: [GiftCard]
    "The ID of the object."
    id: ID!
    "List of order invoices."
    invoices: [Invoice]
    "Informs if an order is fully paid."
    isPaid: Boolean
    "Returns True, if order requires shipping."
    isShippingRequired: Boolean!
    languageCode: String!
    "List of order lines."
    lines: [OrderLine]!
    "List of public metadata items. Can be accessed without permissions."
    metadata: [MetadataItem]!
    "User-friendly number of an order."
    number: String
    "Internal payment status."
    paymentStatus: PaymentChargeStatusEnum
    "User-friendly payment status."
    paymentStatusDisplay: String
    "List of payments for the order."
    payments: [Payment]
    "List of private metadata items.Requires proper staff permissions to access."
    privateMetadata: [MetadataItem]!
    redirectUrl: String
    shippingAddress: Address
    shippingMethod: ShippingMethod
    shippingMethodName: String
    "Total price of shipping."
    shippingPrice: TaxedMoney
    status: OrderStatus!
    "User-friendly order status."
    statusDisplay: String
    "The sum of line prices not including shipping."
    subtotal: TaxedMoney
    token: String!
    "Total amount of the order."
    total: TaxedMoney
    "Amount authorized for the order."
    totalAuthorized: Money
    "The difference between the paid and the order total amount."
    totalBalance: Money!
    "Amount captured by payment."
    totalCaptured: Money
    trackingClientId: String!
    translatedDiscountName: String
    user: User
    "Email address of the customer."
    userEmail: String
    voucher: Voucher
    weight: Weight
}

type OrderCountableConnection {
    edges: [OrderCountableEdge!]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    "A total count of items in the collection."
    totalCount: Int
}

type OrderCountableEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Order!
}

"History log of the order."
type OrderEvent implements Node {
    "Amount of money."
    amount: Float
    "Composed ID of the Fulfillment."
    composedId: String
    "Date when event happened at in ISO 8601 format."
    date: DateTime
    "Email of the customer."
    email: String
    "Type of an email sent to the customer."
    emailType: OrderEventsEmailsEnum
    "The lines fulfilled."
    fulfilledItems: [FulfillmentLine]
    "The ID of the object."
    id: ID!
    "Number of an invoice related to the order."
    invoiceNumber: String
    "The concerned lines."
    lines: [OrderEventOrderLineObject]
    "Content of the event."
    message: String
    "User-friendly number of an order."
    orderNumber: String
    "List of oversold lines names."
    oversoldItems: [String]
    "The payment gateway of the payment."
    paymentGateway: String
    "The payment ID from the payment gateway."
    paymentId: String
    "Number of items."
    quantity: Int
    "Define if shipping costs were included to the refund."
    shippingCostsIncluded: Boolean
    "The transaction reference of captured payment."
    transactionReference: String
    "Order event type."
    type: OrderEventsEnum
    "User who performed the action."
    user: User
    "The warehouse were items were restocked."
    warehouse: Warehouse
}

type OrderEventOrderLineObject {
    "The variant name."
    itemName: String
    "The order line."
    orderLine: OrderLine
    "The variant quantity."
    quantity: Int
}

"Represents order line of particular order."
type OrderLine implements Node {
    "List of allocations across warehouses."
    allocations: [Allocation!]
    digitalContentUrl: DigitalContentUrl
    "The ID of the object."
    id: ID!
    isShippingRequired: Boolean!
    productName: String!
    productSku: String!
    quantity: Int!
    quantityFulfilled: Int!
    taxRate: Float!
    "The main thumbnail for the ordered product."
    thumbnail(
        "Size of thumbnail."
        size: Int
    ): Image
    "Price of the order line."
    totalPrice: TaxedMoney
    "Product name in the customer's language"
    translatedProductName: String!
    "Variant name in the customer's language"
    translatedVariantName: String!
    "Price of the single item in the order line."
    unitPrice: TaxedMoney
    "A purchased product variant. Note: this field may be null if the variant has been removed from stock at all."
    variant: ProductVariant
    variantName: String!
}

"The Relay compliant `PageInfo` type, containing data necessary to paginate this connection."
type PageInfo {
    "When paginating forwards, the cursor to continue."
    endCursor: String
    "When paginating forwards, are there more items?"
    hasNextPage: Boolean!
    "When paginating backwards, are there more items?"
    hasPreviousPage: Boolean!
    "When paginating backwards, the cursor to continue."
    startCursor: String
}

"Represents a payment of a given type."
type Payment implements Node {
    "List of actions that can be performed in the current state of a payment."
    actions: [OrderAction]!
    "Maximum amount of money that can be captured."
    availableCaptureAmount: Money
    "Maximum amount of money that can be refunded."
    availableRefundAmount: Money
    "Total amount captured for this payment."
    capturedAmount: Money
    "Internal payment status."
    chargeStatus: PaymentChargeStatusEnum!
    checkout: Checkout
    created: DateTime!
    "The details of the card used for this payment."
    creditCard: CreditCard
    customerIpAddress: String
    gateway: String!
    "The ID of the object."
    id: ID!
    isActive: Boolean!
    modified: DateTime!
    order: Order
    token: String!
    "Total amount of the payment."
    total: Money
    "List of all transactions within this payment."
    transactions: [Transaction]
}

"Available payment gateway backend with configuration necessary to setup client."
type PaymentGateway {
    "Payment gateway client configuration."
    config: [GatewayConfigLine!]!
    "Payment gateway supported currencies."
    currencies: [String]!
    "Payment gateway ID."
    id: ID!
    "Payment gateway name."
    name: String!
}

"Represents a payment source stored for user in payment gateway, such as credit card."
type PaymentSource {
    "Stored credit card details if available."
    creditCardInfo: CreditCard
    "Payment gateway name."
    gateway: String!
}

"Represents a permission object in a friendly form."
type Permission {
    "Internal code for permission."
    code: PermissionEnum!
    "Describe action(s) allowed to do by permission."
    name: String!
}

"Represents an individual item for sale in the storefront."
type Product implements Node & ObjectWithMetadata {
    "List of attributes assigned to this product."
    attributes: [SelectedAttribute!]!
    "Date when product is available for purchase. "
    availableForPurchase: Date
    category: Category
    "List of availability in channels for the product."
    channelListings: [ProductChannelListing!]
    chargeTaxes: Boolean!
    "List of collections for the product."
    collections: [Collection]
    defaultVariant: ProductVariant
    description: String!
    descriptionJson: JSONString!
    "The ID of the object."
    id: ID!
    "Get a single product image by ID."
    imageById(
        "ID of a product image."
        id: ID
    ): ProductImage
    "List of images for the product."
    images: [ProductImage]
    "Whether the product is in stock and visible or not."
    isAvailable: Boolean
    "Whether the product is available for purchase."
    isAvailableForPurchase: Boolean
    "List of public metadata items. Can be accessed without permissions."
    metadata: [MetadataItem]!
    name: String!
    "Lists the storefront product's pricing, the current price and discounts, only meant for displaying."
    pricing: ProductPricingInfo
    "List of private metadata items.Requires proper staff permissions to access."
    privateMetadata: [MetadataItem]!
    productType: ProductType!
    rating: Float
    seoDescription: String
    seoTitle: String
    slug: String!
    "A type of tax. Assigned by enabled tax gateway"
    taxType: TaxType
    "The main thumbnail for a product."
    thumbnail(
        "Size of thumbnail."
        size: Int
    ): Image
    "Returns translated product fields for the given language code."
    translation(
        "A language code to return the translation for product."
        languageCode: LanguageCodeEnum!
    ): ProductTranslation
    updatedAt: DateTime
    "The storefront URL for the product."
    url: String! @deprecated(reason : "This field will be removed after 2020-07-31.")
    "List of variants for the product."
    variants: [ProductVariant]
    weight: Weight
}

"Represents product channel listing."
type ProductChannelListing implements Node {
    availableForPurchase: Date
    channel: Channel!
    "The price of the cheapest variant (including discounts)."
    discountedPrice: Money
    "The ID of the object."
    id: ID!
    "Whether the product is available for purchase."
    isAvailableForPurchase: Boolean
    isPublished: Boolean!
    "Range of margin percentage value."
    margin: Margin
    "Lists the storefront product's pricing, the current price and discounts, only meant for displaying."
    pricing: ProductPricingInfo
    publicationDate: Date
    "Purchase cost of product."
    purchaseCost: MoneyRange
    visibleInListings: Boolean!
}

type ProductCountableConnection {
    edges: [ProductCountableEdge!]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    "A total count of items in the collection."
    totalCount: Int
}

type ProductCountableEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Product!
}

"Represents a product image."
type ProductImage implements Node {
    alt: String!
    "The ID of the object."
    id: ID!
    sortOrder: Int
    "The URL of the image."
    url(
        "Size of the image."
        size: Int
    ): String!
}

"Represents availability of a product in the storefront."
type ProductPricingInfo {
    "The discount amount if in sale (null otherwise)."
    discount: TaxedMoney
    "The discount amount in the local currency."
    discountLocalCurrency: TaxedMoney
    "Whether it is in sale or not."
    onSale: Boolean
    "The discounted price range of the product variants."
    priceRange: TaxedMoneyRange
    "The discounted price range of the product variants in the local currency."
    priceRangeLocalCurrency: TaxedMoneyRange
    "The undiscounted price range of the product variants."
    priceRangeUndiscounted: TaxedMoneyRange
}

type ProductTranslation implements Node {
    description: String!
    descriptionJson: JSONString!
    "The ID of the object."
    id: ID!
    "Translation language."
    language: LanguageDisplay!
    name: String!
    seoDescription: String
    seoTitle: String
}

"Represents a type of product. It defines what attributes are available to products of this type."
type ProductType implements Node & ObjectWithMetadata {
    availableAttributes(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        filter: AttributeFilterInput,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int
    ): AttributeCountableConnection
    hasVariants: Boolean!
    "The ID of the object."
    id: ID!
    isDigital: Boolean!
    isShippingRequired: Boolean!
    "List of public metadata items. Can be accessed without permissions."
    metadata: [MetadataItem]!
    name: String!
    "List of private metadata items.Requires proper staff permissions to access."
    privateMetadata: [MetadataItem]!
    "Product attributes of that product type."
    productAttributes: [Attribute]
    "List of products of this type."
    products(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Slug of a channel for which the data should be returned."
        channel: String,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int
    ): ProductCountableConnection @deprecated(reason : "Use the top-level `products` query with the `productTypes` filter.")
    slug: String!
    "A type of tax rate."
    taxRate: TaxRateType
    "A type of tax. Assigned by enabled tax gateway"
    taxType: TaxType
    "Variant attributes of that product type."
    variantAttributes(
        "Define scope of returned attributes."
        variantSelection: VariantAttributeScope
    ): [Attribute]
    weight: Weight
}

type ProductTypeCountableConnection {
    edges: [ProductTypeCountableEdge!]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    "A total count of items in the collection."
    totalCount: Int
}

type ProductTypeCountableEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: ProductType!
}

"Represents a version of a product such as different size or color."
type ProductVariant implements Node & ObjectWithMetadata {
    "List of attributes assigned to this variant."
    attributes(
        "Define scope of returned attributes."
        variantSelection: VariantAttributeScope
    ): [SelectedAttribute!]!
    "List of price information in channels for the product."
    channelListings: [ProductVariantChannelListing!]
    "Cost price of the variant."
    costPrice: Money
    "Digital content for the product variant."
    digitalContent: DigitalContent
    "The ID of the object."
    id: ID!
    "List of images for the product variant."
    images: [ProductImage]
    "Whether the variant is in stock and visible or not."
    isAvailable: Boolean @deprecated(reason : "Use the stock field instead. This field will be removed after 2020-07-31.")
    "Gross margin percentage value."
    margin: Int
    "List of public metadata items. Can be accessed without permissions."
    metadata: [MetadataItem]!
    name: String!
    "Lists the storefront variant's pricing, the current price and discounts, only meant for displaying."
    pricing: VariantPricingInfo
    "List of private metadata items.Requires proper staff permissions to access."
    privateMetadata: [MetadataItem]!
    product: Product!
    "Quantity of a product available for sale."
    quantity: Int! @deprecated(reason : "Use the stock field instead. This field will be removed after 2020-07-31.")
    "Quantity allocated for orders."
    quantityAllocated: Int @deprecated(reason : "Use the stock field instead. This field will be removed after 2020-07-31.")
    "Quantity of a product available for sale in one checkout."
    quantityAvailable(
        "Two-letter ISO 3166-1 country code. When provided, the exact quantity from a warehouse operating in shipping zones that contain this country will be returned. Otherwise, it will return the maximum quantity from all shipping zones."
        countryCode: CountryCode
    ): Int!
    "Total quantity ordered."
    quantityOrdered: Int
    "Total revenue generated by a variant in given period of time. Note: this field should be queried using `reportProductSales` query as it uses optimizations suitable for such calculations."
    revenue(period: ReportingPeriod): TaxedMoney
    sku: String!
    "Quantity of a product available for sale."
    stockQuantity: Int! @deprecated(reason : "Use the quantityAvailable field instead. This field will be removed after 2020-07-31.")
    "Stocks for the product variant."
    stocks(
        "Two-letter ISO 3166-1 country code."
        countryCode: CountryCode
    ): [Stock]
    trackInventory: Boolean!
    "Returns translated product variant fields for the given language code."
    translation(
        "A language code to return the translation for product variant."
        languageCode: LanguageCodeEnum!
    ): ProductVariantTranslation
    weight: Weight
}

"Represents product varaint channel listing."
type ProductVariantChannelListing implements Node {
    channel: Channel!
    "Cost price of the variant."
    costPrice: Money
    "The ID of the object."
    id: ID!
    "Gross margin percentage value."
    margin: Int
    price: Money
}

type ProductVariantTranslation implements Node {
    "The ID of the object."
    id: ID!
    "Translation language."
    language: LanguageDisplay!
    name: String!
}

type Query {
    "The ID of the object"
    review(id: ID!): Review
    "List of reviews."
    reviews(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Filtering options for reviews."
        filter: ReviewFilterInput,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int,
        "Sorting options for reviews."
        sortBy: ReviewSortingInput
    ): ReviewCountableConnection
}

"Represents a reduced VAT rate for a particular type of goods."
type ReducedRate {
    "Reduced VAT rate in percent."
    rate: Float!
    "A type of goods."
    rateType: TaxRateType!
}

type Review implements Node & ObjectWithMetadata {
    content: String!
    created: Date!
    "The ID of the object."
    id: ID!
    "List of public metadata items. Can be accessed without permissions."
    metadata: [MetadataItem]!
    "List of private metadata items.Requires proper staff permissions to access."
    privateMetadata: [MetadataItem]!
    product: Product!
    rating: Int!
    user: User!
}

type ReviewCountableConnection {
    edges: [ReviewCountableEdge!]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    "A total count of items in the collection."
    totalCount: Int
}

type ReviewCountableEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Review!
}

"Create a review"
type ReviewCreateMutation {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    review: Review
    reviewsErrors: [ReviewError!]!
}

type ReviewError {
    "The error code."
    code: ReviewErrorCode!
    "Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field."
    field: String
    "The error message."
    message: String
}

"Update a review by ID"
type ReviewUpdateMutation {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    review: Review
    reviewsErrors: [ReviewError!]!
}

"Represents a custom attribute."
type SelectedAttribute {
    "Name of an attribute displayed in the interface."
    attribute: Attribute!
    "Values of an attribute."
    values: [AttributeValue]!
}

"Shipping method are the methods you'll use to get customer's orders to them. They are directly exposed to the customers."
type ShippingMethod implements Node & ObjectWithMetadata {
    "List of channels available for the method."
    channelListings: [ShippingMethodChannelListing!]
    "List of excluded products for the shipping method."
    excludedProducts(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int
    ): ProductCountableConnection
    "The ID of the object."
    id: ID!
    maximumDeliveryDays: Int
    "The price of the cheapest variant (including discounts)."
    maximumOrderPrice: Money
    maximumOrderWeight: Weight
    "List of public metadata items. Can be accessed without permissions."
    metadata: [MetadataItem]!
    minimumDeliveryDays: Int
    "The price of the cheapest variant (including discounts)."
    minimumOrderPrice: Money
    minimumOrderWeight: Weight
    name: String!
    "The price of the cheapest variant (including discounts)."
    price: Money
    "List of private metadata items.Requires proper staff permissions to access."
    privateMetadata: [MetadataItem]!
    "Returns translated shipping method fields for the given language code."
    translation(
        "A language code to return the translation for shipping method."
        languageCode: LanguageCodeEnum!
    ): ShippingMethodTranslation
    "Type of the shipping method."
    type: ShippingMethodTypeEnum
    "Zip code exclude range of the shipping method."
    zipCodeRules: [ShippingMethodZipCodeRule]
}

"Represents shipping method channel listing."
type ShippingMethodChannelListing implements Node {
    channel: Channel!
    "The ID of the object."
    id: ID!
    maximumOrderPrice: Money
    minimumOrderPrice: Money
    price: Money
}

type ShippingMethodTranslation implements Node {
    "The ID of the object."
    id: ID!
    "Translation language."
    language: LanguageDisplay!
    name: String
}

"Represents shipping method zip code."
type ShippingMethodZipCodeRule implements Node {
    "End address range."
    end: String
    "The ID of the object."
    id: ID!
    "Start address range."
    start: String
}

"Represents a shipping zone in the shop. Zones are the concept used only for grouping shipping methods in the dashboard, and are never exposed to the customers directly."
type ShippingZone implements Node & ObjectWithMetadata {
    "List of countries available for the method."
    countries: [CountryDisplay]
    default: Boolean!
    "The ID of the object."
    id: ID!
    "List of public metadata items. Can be accessed without permissions."
    metadata: [MetadataItem]!
    name: String!
    "Lowest and highest prices for the shipping."
    priceRange: MoneyRange
    "List of private metadata items.Requires proper staff permissions to access."
    privateMetadata: [MetadataItem]!
    "List of shipping methods available for orders shipped to countries within this shipping zone."
    shippingMethods: [ShippingMethod]
    "List of warehouses for shipping zone."
    warehouses: [Warehouse]
}

type ShippingZoneCountableConnection {
    edges: [ShippingZoneCountableEdge!]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    "A total count of items in the collection."
    totalCount: Int
}

type ShippingZoneCountableEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: ShippingZone!
}

"Represents stock."
type Stock implements Node {
    "The ID of the object."
    id: ID!
    productVariant: ProductVariant!
    "Quantity of a product in the warehouse's possession, including the allocated stock that is waiting for shipment."
    quantity: Int!
    "Quantity allocated for orders"
    quantityAllocated: Int!
    warehouse: Warehouse!
}

"Representation of tax types fetched from tax gateway."
type TaxType {
    "Description of the tax type."
    description: String
    "External tax code used to identify given tax group."
    taxCode: String
}

"Represents a monetary value with taxes. In cases where taxes were not applied, net and gross values will be equal."
type TaxedMoney {
    "Currency code."
    currency: String!
    "Amount of money including taxes."
    gross: Money!
    "Amount of money without taxes."
    net: Money!
    "Amount of taxes."
    tax: Money!
}

"Represents a range of monetary values."
type TaxedMoneyRange {
    "Lower bound of a price range."
    start: TaxedMoney
    "Upper bound of a price range."
    stop: TaxedMoney
}

"An object representing a single payment."
type Transaction implements Node {
    "Total amount of the transaction."
    amount: Money
    created: DateTime!
    error: TransactionError
    "The ID of the object."
    id: ID!
    isSuccess: Boolean!
    kind: TransactionKind!
    payment: Payment!
    token: String!
}

"Represents user data."
type User implements Node & ObjectWithMetadata {
    "List of all user's addresses."
    addresses: [Address]
    avatar(
        "Size of the avatar."
        size: Int
    ): Image
    "Returns the last open checkout of this user."
    checkout: Checkout @deprecated(reason : "Use the `checkout_tokens` field to fetch the user checkouts.")
    "Returns the checkout UUID's assigned to this user."
    checkoutTokens(
        "Slug of a channel for which the data should be returned."
        channel: String
    ): [UUID!]
    dateJoined: DateTime!
    defaultBillingAddress: Address
    defaultShippingAddress: Address
    "List of user's permission groups which user can manage."
    editableGroups: [Group]
    email: String!
    "List of events associated with the user."
    events: [CustomerEvent]
    firstName: String!
    "List of the user gift cards."
    giftCards(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int
    ): GiftCardCountableConnection
    "The ID of the object."
    id: ID!
    isActive: Boolean!
    isStaff: Boolean!
    lastLogin: DateTime
    lastName: String!
    "List of public metadata items. Can be accessed without permissions."
    metadata: [MetadataItem]!
    "A note about the customer."
    note: String
    "List of user's orders."
    orders(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int
    ): OrderCountableConnection
    "List of user's permission groups."
    permissionGroups: [Group]
    "List of user's permissions."
    permissions: [Permission] @deprecated(reason : "Will be removed in Saleor 2.11.Use the `userPermissions` instead.")
    "List of private metadata items.Requires proper staff permissions to access."
    privateMetadata: [MetadataItem]!
    "List of stored payment sources."
    storedPaymentSources: [PaymentSource]
    "List of user's permissions."
    userPermissions: [UserPermission]
}

type UserPermission {
    "Internal code for permission."
    code: PermissionEnum!
    "Describe action(s) allowed to do by permission."
    name: String!
    "List of user permission groups which contains this permission."
    sourcePermissionGroups(
        "ID of user whose groups should be returned."
        userId: ID!
    ): [Group!]
}

"Represents a VAT rate for a country."
type VAT {
    "Country code."
    countryCode: String!
    "Country's VAT rate exceptions for specific types of goods."
    reducedRates: [ReducedRate]!
    "Standard VAT rate in percent."
    standardRate: Float
}

"Represents availability of a variant in the storefront."
type VariantPricingInfo {
    "The discount amount if in sale (null otherwise)."
    discount: TaxedMoney
    "The discount amount in the local currency."
    discountLocalCurrency: TaxedMoney
    "Whether it is in sale or not."
    onSale: Boolean
    "The price, with any discount subtracted."
    price: TaxedMoney
    "The discounted price in the local currency."
    priceLocalCurrency: TaxedMoney
    "The price without any discount."
    priceUndiscounted: TaxedMoney
}

"Vouchers allow giving discounts to particular customers on categories, collections or specific products. They can be used during checkout by providing valid voucher codes."
type Voucher implements Node {
    applyOncePerCustomer: Boolean!
    applyOncePerOrder: Boolean!
    "List of categories this voucher applies to."
    categories(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int
    ): CategoryCountableConnection
    "List of availability in channels for the voucher."
    channelListings: [VoucherChannelListing!]
    code: String!
    "List of collections this voucher applies to."
    collections(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int
    ): CollectionCountableConnection
    "List of countries available for the shipping voucher."
    countries: [CountryDisplay]
    "Currency code for voucher."
    currency: String
    "Voucher value."
    discountValue: Float
    "Determines a type of discount for voucher - value or percentage"
    discountValueType: DiscountValueTypeEnum!
    endDate: DateTime
    "The ID of the object."
    id: ID!
    minCheckoutItemsQuantity: Int
    "Minimum order value to apply voucher."
    minSpent: Money
    name: String
    "List of products this voucher applies to."
    products(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int
    ): ProductCountableConnection
    startDate: DateTime!
    "Returns translated voucher fields for the given language code."
    translation(
        "A language code to return the translation for voucher."
        languageCode: LanguageCodeEnum!
    ): VoucherTranslation
    "Determines a type of voucher."
    type: VoucherTypeEnum!
    usageLimit: Int
    used: Int!
}

"Represents voucher channel listing."
type VoucherChannelListing implements Node {
    channel: Channel!
    currency: String!
    discountValue: Float!
    "The ID of the object."
    id: ID!
    minSpent: Money
}

type VoucherTranslation implements Node {
    "The ID of the object."
    id: ID!
    "Translation language."
    language: LanguageDisplay!
    name: String
}

"Represents warehouse."
type Warehouse implements Node {
    address: Address!
    companyName: String!
    email: String!
    "The ID of the object."
    id: ID!
    name: String!
    shippingZones(after: String, before: String, first: Int, last: Int): ShippingZoneCountableConnection!
    slug: String!
}

"Represents weight value in a specific weight unit."
type Weight {
    "Weight unit."
    unit: WeightUnitsEnum!
    "Weight value."
    value: Float!
}

"An enumeration."
enum AttributeInputTypeEnum {
    DROPDOWN
    FILE
    MULTISELECT
}

"An enumeration."
enum AttributeTypeEnum {
    PAGE_TYPE
    PRODUCT_TYPE
}

enum AttributeValueType {
    COLOR
    GRADIENT
    STRING
    URL
}

"An enumeration."
enum CountryCode {
    AD
    AE
    AF
    AG
    AI
    AL
    AM
    AO
    AQ
    AR
    AS
    AT
    AU
    AW
    AX
    AZ
    BA
    BB
    BD
    BE
    BF
    BG
    BH
    BI
    BJ
    BL
    BM
    BN
    BO
    BQ
    BR
    BS
    BT
    BV
    BW
    BY
    BZ
    CA
    CC
    CD
    CF
    CG
    CH
    CI
    CK
    CL
    CM
    CN
    CO
    CR
    CU
    CV
    CW
    CX
    CY
    CZ
    DE
    DJ
    DK
    DM
    DO
    DZ
    EC
    EE
    EG
    EH
    ER
    ES
    ET
    EU
    FI
    FJ
    FK
    FM
    FO
    FR
    GA
    GB
    GD
    GE
    GF
    GG
    GH
    GI
    GL
    GM
    GN
    GP
    GQ
    GR
    GS
    GT
    GU
    GW
    GY
    HK
    HM
    HN
    HR
    HT
    HU
    ID
    IE
    IL
    IM
    IN
    IO
    IQ
    IR
    IS
    IT
    JE
    JM
    JO
    JP
    KE
    KG
    KH
    KI
    KM
    KN
    KP
    KR
    KW
    KY
    KZ
    LA
    LB
    LC
    LI
    LK
    LR
    LS
    LT
    LU
    LV
    LY
    MA
    MC
    MD
    ME
    MF
    MG
    MH
    MK
    ML
    MM
    MN
    MO
    MP
    MQ
    MR
    MS
    MT
    MU
    MV
    MW
    MX
    MY
    MZ
    NA
    NC
    NE
    NF
    NG
    NI
    NL
    NO
    NP
    NR
    NU
    NZ
    OM
    PA
    PE
    PF
    PG
    PH
    PK
    PL
    PM
    PN
    PR
    PS
    PT
    PW
    PY
    QA
    RE
    RO
    RS
    RU
    RW
    SA
    SB
    SC
    SD
    SE
    SG
    SH
    SI
    SJ
    SK
    SL
    SM
    SN
    SO
    SR
    SS
    ST
    SV
    SX
    SY
    SZ
    TC
    TD
    TF
    TG
    TH
    TJ
    TK
    TL
    TM
    TN
    TO
    TR
    TT
    TV
    TW
    TZ
    UA
    UG
    UM
    US
    UY
    UZ
    VA
    VC
    VE
    VG
    VI
    VN
    VU
    WF
    WS
    YE
    YT
    ZA
    ZM
    ZW
}

"An enumeration."
enum CustomerEventsEnum {
    ACCOUNT_CREATED
    CUSTOMER_DELETED
    DIGITAL_LINK_DOWNLOADED
    EMAIL_ASSIGNED
    EMAIL_CHANGED
    EMAIL_CHANGED_REQUEST
    NAME_ASSIGNED
    NOTE_ADDED
    NOTE_ADDED_TO_ORDER
    PASSWORD_CHANGED
    PASSWORD_RESET
    PASSWORD_RESET_LINK_SENT
    PLACED_ORDER
}

enum DiscountValueTypeEnum {
    FIXED
    PERCENTAGE
}

"An enumeration."
enum FulfillmentStatus {
    "Canceled"
    CANCELED
    "Fulfilled"
    FULFILLED
    "Refunded"
    REFUNDED
}

"An enumeration."
enum JobStatusEnum {
    DELETED
    FAILED
    PENDING
    SUCCESS
}

"An enumeration."
enum LanguageCodeEnum {
    AR
    AZ
    BG
    BN
    CA
    CS
    DA
    DE
    EL
    EN
    ES
    ES_CO
    ET
    FA
    FI
    FR
    HI
    HU
    HY
    ID
    IS
    IT
    JA
    KA
    KM
    KO
    LT
    MN
    MY
    NB
    NL
    PL
    PT
    PT_BR
    RO
    RU
    SK
    SL
    SQ
    SR
    SV
    SW
    TA
    TH
    TR
    UK
    VI
    ZH_HANS
    ZH_HANT
}

enum OrderAction {
    "Represents the capture action."
    CAPTURE
    "Represents a mark-as-paid action."
    MARK_AS_PAID
    "Represents a refund action."
    REFUND
    "Represents a void action."
    VOID
}

enum OrderDirection {
    "Specifies an ascending sort order."
    ASC
    "Specifies a descending sort order."
    DESC
}

"An enumeration."
enum OrderEventsEmailsEnum {
    CONFIRMED
    DIGITAL_LINKS
    FULFILLMENT_CONFIRMATION
    ORDER_CANCEL
    ORDER_CONFIRMATION
    ORDER_REFUND
    PAYMENT_CONFIRMATION
    SHIPPING_CONFIRMATION
    TRACKING_UPDATED
}

"An enumeration."
enum OrderEventsEnum {
    CANCELED
    CONFIRMED
    DRAFT_ADDED_PRODUCTS
    DRAFT_CREATED
    DRAFT_REMOVED_PRODUCTS
    EMAIL_SENT
    EXTERNAL_SERVICE_NOTIFICATION
    FULFILLMENT_CANCELED
    FULFILLMENT_FULFILLED_ITEMS
    FULFILLMENT_REFUNDED
    FULFILLMENT_RESTOCKED_ITEMS
    INVOICE_GENERATED
    INVOICE_REQUESTED
    INVOICE_SENT
    INVOICE_UPDATED
    NOTE_ADDED
    ORDER_FULLY_PAID
    ORDER_MARKED_AS_PAID
    OTHER
    OVERSOLD_ITEMS
    PAYMENT_AUTHORIZED
    PAYMENT_CAPTURED
    PAYMENT_FAILED
    PAYMENT_REFUNDED
    PAYMENT_VOIDED
    PLACED
    PLACED_FROM_DRAFT
    TRACKING_UPDATED
    UPDATED_ADDRESS
}

"An enumeration."
enum OrderStatus {
    "Canceled"
    CANCELED
    "Draft"
    DRAFT
    "Fulfilled"
    FULFILLED
    "Partially fulfilled"
    PARTIALLY_FULFILLED
    "Unconfirmed"
    UNCONFIRMED
    "Unfulfilled"
    UNFULFILLED
}

"An enumeration."
enum PaymentChargeStatusEnum {
    CANCELLED
    FULLY_CHARGED
    FULLY_REFUNDED
    NOT_CHARGED
    PARTIALLY_CHARGED
    PARTIALLY_REFUNDED
    PENDING
    REFUSED
}

"An enumeration."
enum PermissionEnum {
    MANAGE_APPS
    MANAGE_CHANNELS
    MANAGE_CHECKOUTS
    MANAGE_DISCOUNTS
    MANAGE_GIFT_CARD
    MANAGE_MENUS
    MANAGE_ORDERS
    MANAGE_PAGES
    MANAGE_PAGE_TYPES_AND_ATTRIBUTES
    MANAGE_PLUGINS
    MANAGE_PRODUCTS
    MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES
    MANAGE_SETTINGS
    MANAGE_SHIPPING
    MANAGE_STAFF
    MANAGE_TRANSLATIONS
    MANAGE_USERS
}

enum ProductOrderField {
    "Sort products by collection. Note: This option is available only for the `Collection.products` query."
    COLLECTION
    "Sort products by update date."
    DATE
    "Sort products by a minimal price of a product's variant."
    MINIMAL_PRICE
    "Sort products by name."
    NAME
    "Sort products by price."
    PRICE
    "Sort products by publication date."
    PUBLICATION_DATE
    "Sort products by publication status."
    PUBLISHED
    "Sort products by rating."
    RATING
    "Sort products by type."
    TYPE
}

enum ReportingPeriod {
    THIS_MONTH
    TODAY
}

"An enumeration."
enum ReviewErrorCode {
    EXISTS
    REQUESTOR_NOT_AUTHOR
}

enum ReviewSortField {
    "Sort reviews by creation date."
    CREATION_DATE
    "Sort reviews by rating."
    RATING
}

"An enumeration."
enum ShippingMethodTypeEnum {
    PRICE
    WEIGHT
}

enum StockAvailability {
    IN_STOCK
    OUT_OF_STOCK
}

"An enumeration."
enum TaxRateType {
    ACCOMMODATION
    ADMISSION_TO_CULTURAL_EVENTS
    ADMISSION_TO_ENTERTAINMENT_EVENTS
    ADMISSION_TO_SPORTING_EVENTS
    ADVERTISING
    AGRICULTURAL_SUPPLIES
    BABY_FOODSTUFFS
    BIKES
    BOOKS
    CHILDRENS_CLOTHING
    DOMESTIC_FUEL
    DOMESTIC_SERVICES
    E_BOOKS
    FOODSTUFFS
    HOTELS
    MEDICAL
    NEWSPAPERS
    PASSENGER_TRANSPORT
    PHARMACEUTICALS
    PROPERTY_RENOVATIONS
    RESTAURANTS
    SOCIAL_HOUSING
    STANDARD
    WATER
    WINE
}

"An enumeration."
enum TransactionError {
    "declined"
    TRANSACTIONERROR_DECLINED
    "expired"
    TRANSACTIONERROR_EXPIRED
    "incorrect_address"
    TRANSACTIONERROR_INCORRECT_ADDRESS
    "incorrect_cvv"
    TRANSACTIONERROR_INCORRECT_CVV
    "incorrect_number"
    TRANSACTIONERROR_INCORRECT_NUMBER
    "incorrect_zip"
    TRANSACTIONERROR_INCORRECT_ZIP
    "invalid_cvv"
    TRANSACTIONERROR_INVALID_CVV
    "invalid_expiry_date"
    TRANSACTIONERROR_INVALID_EXPIRY_DATE
    "invalid_number"
    TRANSACTIONERROR_INVALID_NUMBER
    "processing_error"
    TRANSACTIONERROR_PROCESSING_ERROR
}

"An enumeration."
enum TransactionKind {
    "Action to confirm"
    ACTION_TO_CONFIRM
    "Authorization"
    AUTH
    "Cancel"
    CANCEL
    "Capture"
    CAPTURE
    "Confirm"
    CONFIRM
    "External reference"
    EXTERNAL
    "Pending"
    PENDING
    "Refund"
    REFUND
    "Refund in progress"
    REFUND_ONGOING
    "Void"
    VOID
}

enum VariantAttributeScope {
    ALL
    NOT_VARIANT_SELECTION
    VARIANT_SELECTION
}

enum VoucherTypeEnum {
    ENTIRE_ORDER
    SHIPPING
    SPECIFIC_PRODUCT
}

"An enumeration."
enum WeightUnitsEnum {
    G
    KG
    LB
    OZ
}

input AttributeFilterInput {
    availableInGrid: Boolean
    "Specifies the channel by which the data should be sorted."
    channel: String
    filterableInDashboard: Boolean
    filterableInStorefront: Boolean
    ids: [ID]
    inCategory: ID
    inCollection: ID
    isVariantOnly: Boolean
    search: String
    type: AttributeTypeEnum
    valueRequired: Boolean
    visibleInStorefront: Boolean
}

input AttributeInput {
    "Internal representation of an attribute name."
    slug: String!
    "[Deprecated] Internal representation of a value (unique per attribute). This field will be removed after 2020-07-31."
    value: String
    "Internal representation of a value (unique per attribute)."
    values: [String]
}

input IntRangeInput {
    "Value greater than or equal to."
    gte: Int
    "Value less than or equal to."
    lte: Int
}

input PriceRangeInput {
    "Price greater than or equal to."
    gte: Float
    "Price less than or equal to."
    lte: Float
}

input ProductFilterInput {
    attributes: [AttributeInput]
    categories: [ID]
    "Specifies the channel by which the data should be sorted."
    channel: String
    collections: [ID]
    hasCategory: Boolean
    ids: [ID]
    isPublished: Boolean
    minimalPrice: PriceRangeInput
    price: PriceRangeInput
    productType: ID
    productTypes: [ID]
    search: String
    stockAvailability: StockAvailability
    stocks: ProductStockFilterInput
}

input ProductOrder {
    """

    Sort product by the selected attribute's values.
    Note: this doesn't take translations into account yet.
    """
    attributeId: ID
    "Specifies the channel in which to sort the data."
    channel: String
    "Specifies the direction in which to sort products."
    direction: OrderDirection!
    "Sort products by the selected field."
    field: ProductOrderField
}

input ProductStockFilterInput {
    quantity: IntRangeInput
    warehouseIds: [ID!]
}

input ReviewCreateInput {
    content: String!
    product: ID
    rating: Int!
}

input ReviewFilterInput {
    product: ID
    rating: IntRangeInput
    user: ID
}

input ReviewSortingInput {
    "Specifies the direction in which to sort products."
    direction: OrderDirection!
    "Sort review by the selected field."
    field: ReviewSortField!
}

input ReviewUpdateInput {
    content: String
    id: ID
    rating: Int
}


"""
The `DateTime` scalar type represents a DateTime
value as specified by
[iso8601](https://en.wikipedia.org/wiki/ISO_8601).
"""
scalar DateTime

"""
The `Date` scalar type represents a Date
value as specified by
[iso8601](https://en.wikipedia.org/wiki/ISO_8601).
"""
scalar Date

"""
Allows use of a JSON String for input / output from the GraphQL schema.

Use of this type is *not recommended* as you lose the benefits of having a defined, static
schema (one of the key benefits of GraphQL).
"""
scalar JSONString

scalar UUID
